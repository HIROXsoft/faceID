<!DOCTYPE html>
<html>
<head>
  <base target="_top">
  <meta charset="UTF-8" />
  <title>顔認証</title>
  <script src="https://unpkg.com/face-api.js@0.22.2/dist/face-api.min.js"></script>

  <style>
    :root { font-size: 16px; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #f5f5f5;
      margin: 0;
      padding: 16px;
    }
    h1 { margin: 0 0 12px; text-align: center; }

    .panel {
      background: #fff;
      border-radius: 12px;
      padding: 12px 14px;
      margin: 12px auto;
      max-width: 720px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    .camera-wrap { display: flex; flex-direction: column; align-items: center; }
    .video-wrapper { position: relative; display: inline-block; }
    video { border-radius: 12px; background: #000; }

    /* 緑のガイド枠（少し小さく） */
    .guide-rect{
      position:absolute;
      left:50%; top:50%;
      width:62%;
      height:68%;
      transform:translate(-50%,-50%);
      border: 2px solid rgba(0,255,0,0.85);
      border-radius: 999px;
      box-sizing:border-box;
      pointer-events:none;
    }

    #status { font-size: 0.9rem; margin-top: 10px; text-align: center; }

    .btn{
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 1rem;
      margin: 6px 6px 6px 0;
    }
    .btn-primary{ background:#1976d2; border-color:#1976d2; color:#fff; }

    #log {
      font-size: 0.85rem;
      max-height: 240px;
      overflow-y: auto;
      background: #fafafa;
      padding: 6px 10px;
      border-radius: 10px;
    }

    /* 1週間表示 */
    .weekly-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
    .weekly-table th, .weekly-table td { border: 1px solid #ddd; padding: 6px 8px; text-align: center; }
    .weekly-table th { background: #f0f0f0; }
    .weekly-missing { background: #ffecec; }
    .weekly-ok { background: #f7fff7; }
    .weekly-holiday { background: #eef6ff; }

    /* ガイド オーバーレイ */
    #guideOverlay{
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.45);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 9999;
    }
    .guideBox{
      width: min(460px, 92vw);
      background:#fff;
      border-radius: 16px;
      padding: 14px;
      text-align:center;
      box-shadow: 0 12px 30px rgba(0,0,0,0.2);
    }
    .guideMessage{
      font-size: 16px;
      line-height: 1.5;
      margin: 8px 0 10px;
      white-space: pre-line;
    }
    .guideBtnRow{
      display:flex;
      gap: 10px;
      margin-top: 10px;
    }
    .guideBtn{
      flex: 1;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 16px;
      background: #fff;
    }
    .guideBtnPrimary{
      border-color:#1976d2;
      background:#1976d2;
      color:#fff;
    }

    .guideArrow{
      width: 0; height: 0;
      margin: 0 auto 10px;
      border-style: solid;
    }
    .arrow-none{ display:none; }
    .arrow-up{
      border-width: 0 16px 22px 16px;
      border-color: transparent transparent #1976d2 transparent;
    }
    .arrow-right{
      border-width: 16px 0 16px 22px;
      border-color: transparent transparent transparent #1976d2;
    }
    .arrow-left{
      border-width: 16px 22px 16px 0;
      border-color: transparent #1976d2 transparent transparent;
    }

    /* ガイド内の入力・選択UI */
    .guideInputWrap, .guideSelectWrap{
      display:none;
      margin: 10px 0 0;
      text-align:left;
    }
    .guideInput, .guideSelect{
      width: 100%;
      padding: 10px 12px;
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid #ccc;
      box-sizing:border-box;
    }
    .guideHint{
      font-size: 12px;
      color:#666;
      margin-top: 6px;
      white-space: pre-line;
      text-align:left;
    }
    .guideCancel{
      display:none;
      flex: 1;
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid #ccc;
      cursor: pointer;
      font-size: 16px;
      background: #fff;
    }

    /* 既存UIの row 定義（必要なら） */
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .input{
      padding:10px 12px; border-radius:10px; border:1px solid #ccc; font-size:16px;
    }
    .small{ font-size:12px; color:#666; }
  </style>
</head>

<body>
  <h1>顔認証出退勤</h1>

  <!-- 外部ホスト設定（GAS内で開いた場合は非表示） -->
  <div class="panel" id="extSettings" style="display:none">
    <h3 style="margin-top:0;">外部ホスト設定</h3>
    <div class="row">
      <input id="webappUrl" class="input" style="min-width:340px;flex:1" placeholder="GAS WebアプリURL（.../exec）">
      <input id="apiKey" class="input" style="min-width:240px" placeholder="APIキー">
      <button class="btn btn-primary" onclick="saveSettings()">保存</button>
      <button class="btn" onclick="apiPing()">疎通確認</button>
    </div>
    <div class="small" style="margin-top:6px;color:#666">※外部ホストからはJSONPでGASを呼び出します（CORS回避）。</div>
  </div>

  <!-- ① 顔登録（最上部） -->
  <div class="panel">
    <h3>① 顔登録（3回：正面→右→左）</h3>
    <p style="font-size:0.95rem;">
      ガイド枠の中に<strong>自分の顔だけ</strong>が入るように立ってください。<br>
      「この顔を登録」を<strong>1回</strong>押すと、以降はポップアップの案内だけで3回撮影して完了します。
    </p>
    <button class="btn btn-primary" onclick="onRegisterFace()">この顔を登録</button>
  </div>

  <!-- カメラ（中央） -->
  <div class="panel camera-wrap">
    <div class="video-wrapper">
      <video id="video" width="640" height="480" autoplay muted playsinline></video>
      <div class="guide-rect"></div>
    </div>
    <div id="status">初期化中...</div>
    <div style="margin-top:6px;">認識されたユーザー: <b><span id="userName">未認識</span></b></div>
  </div>

  <!-- ② 顔認証 -->
  <div class="panel">
    <h3>② 顔認証 → 出勤 / 退勤</h3>
    <button class="btn btn-primary" onclick="onRecognizeFace()">顔認証</button>

    <hr />

    <h4>出勤</h4>
    <button class="btn btn-primary" onclick="onClickStart()">出勤打刻</button>

    <h4>退勤</h4>
    <button class="btn btn-primary" onclick="onClickEnd()">退勤打刻</button>
  </div>

  <!-- 私用外出 -->
  <div class="panel">
    <h3>私用外出</h3>
    <p style="font-size:0.9rem;">外出開始と戻りを記録します</p>
    <div style="margin-bottom:8px;">
      <input type="text" id="privateMemo" placeholder="メモ（任意）" style="width:320px; padding:8px; border:1px solid #ccc; border-radius:10px;">
    </div>
    <button class="btn btn-primary" onclick="onPrivateOut()">外出開始</button>
    <button class="btn btn-primary" onclick="onPrivateBack()">戻り</button>
  </div>

  <!-- 直近7日 -->
  <div class="panel">
    <h3>今週の出退勤（月〜日）</h3>
    <div id="weeklyStatus">顔認証後に読み込みます...</div>
  </div>

  <!-- ③ 修正 -->
  <div class="panel">
    <h3>③ 打刻の修正</h3>
    <p style="font-size:0.9rem;">
      修正した場合、各所長または部署責任者へメールにて修正理由と併せてご連絡ください。
    </p>

    <div style="margin-bottom:8px;">
      <label style="font-size:0.9rem;">対象日： <input type="date" id="editDate"></label>
    </div>

    <div style="margin-bottom:8px;">
      <label style="font-size:0.9rem;">項目：
        <select id="editField" style="padding:8px;border-radius:10px;border:1px solid #ccc">
          <option value="start">出勤</option>
          <option value="end">退勤</option>
        </select>
      </label>
    </div>

    <div style="margin-bottom:8px;">
      <label style="font-size:0.9rem;">修正方法：
        <select id="editMode" style="padding:8px;border-radius:10px;border:1px solid #ccc">
          <option value="set">時刻を入力して上書き</option>
          <option value="clear">空白にする（削除）</option>
        </select>
      </label>
    </div>

    <div style="margin-bottom:8px;">
      <label style="font-size:0.9rem;">時刻（HH:MM）： <input type="time" id="editTime"></label>
    </div>

    <div style="margin-bottom:8px;">
      <label style="font-size:0.9rem;">自由記入（任意）：
        <input type="text" id="editFreeText" placeholder="理由など" style="width:320px; padding:8px; border:1px solid #ccc; border-radius:10px;">
      </label>
    </div>

    <button class="btn btn-primary" onclick="onEdit()">修正を保存</button>
  </div>

  <!-- ログ -->
  <div class="panel">
    <h3 style="margin-top:0;">ログ</h3>
    <div id="log"></div>
  </div>

  <!-- ★承認パネル（画面下部へ移植） -->
  <div class="panel" id="approvePanel" style="display:none">
    <h3 style="margin-top:0;">修正履歴の承認（確認者）</h3>
    <div class="small" style="color:#666;margin-bottom:8px">
      顔認証で認識したユーザー名を確認者として、未承認の修正一覧を表示します。
    </div>
    <div class="row" style="gap:8px;flex-wrap:wrap">
      <button class="btn btn-primary" onclick="loadPendingEdits(true)">未承認一覧を取得</button>
      <span class="small" id="approveHint" style="color:#666"></span>
    </div>

    <div style="overflow:auto;max-height:50vh;margin-top:10px">
      <table style="width:100%;border-collapse:collapse">
        <thead>
          <tr>
            <th style="text-align:left;padding:8px 6px;border-bottom:1px solid #eee;background:#fafafa;position:sticky;top:0;min-width:84px">操作</th>
            <th style="text-align:left;padding:8px 6px;border-bottom:1px solid #eee;background:#fafafa;position:sticky;top:0;min-width:110px">対象者</th>
            <th style="text-align:left;padding:8px 6px;border-bottom:1px solid #eee;background:#fafafa;position:sticky;top:0;min-width:100px">日付</th>
            <th style="text-align:left;padding:8px 6px;border-bottom:1px solid #eee;background:#fafafa;position:sticky;top:0;min-width:120px">項目</th>
            <th style="text-align:left;padding:8px 6px;border-bottom:1px solid #eee;background:#fafafa;position:sticky;top:0;min-width:160px">変更前 → 変更後</th>
            <th style="text-align:left;padding:8px 6px;border-bottom:1px solid #eee;background:#fafafa;position:sticky;top:0;min-width:220px">ログ情報</th>
          </tr>
        </thead>
        <tbody id="approveTbody">
          <tr><td colspan="6" class="small" style="padding:10px 6px;color:#666">未承認一覧はまだ取得していません。</td></tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- ガイド オーバーレイ -->
  <div id="guideOverlay">
    <div class="guideBox">
      <div class="guideArrow arrow-none" id="guideArrow"></div>
      <div class="guideMessage" id="guideMessage"></div>

      <div class="guideInputWrap" id="guideInputWrap">
        <input class="guideInput" id="guideInput" />
        <div class="guideHint" id="guideInputHint"></div>
      </div>

      <div class="guideSelectWrap" id="guideSelectWrap">
        <select class="guideSelect" id="guideSelect"></select>
        <div class="guideHint" id="guideSelectHint"></div>
      </div>

      <div class="guideBtnRow">
        <button class="guideBtn guideCancel" id="guideCancelBtn">キャンセル</button>
        <button class="guideBtn guideBtnPrimary" id="guideBtn">OK</button>
      </div>
    </div>
  </div>

<script>
/* ============================================================
   既存ロジック（APIキー入力欄などUI構造は維持）
   ============================================================ */

const video = document.getElementById('video');
const statusEl = document.getElementById('status');
const userNameEl = document.getElementById('userName');
let labeledDescriptors = [];
let recognizedName = '';
let modelsLoaded = false;
let modelsLoadingPromise = null;
let registerInProgress = false;

const LS_URL='attend_webapp_url';
const LS_KEY='attend_api_key';

/* ---------- util log ---------- */
function log(m){
  const el=document.getElementById('log');
  if(!el) return;
  const p=document.createElement('div');
  p.textContent='['+new Date().toLocaleTimeString()+'] '+m;
  el.prepend(p);
}

/* ---------- guide overlay ---------- */
const guideOverlay = document.getElementById('guideOverlay');
const guideArrowEl = document.getElementById('guideArrow');
const guideMessage = document.getElementById('guideMessage');
const guideBtn = document.getElementById('guideBtn');
const guideCancelBtn = document.getElementById('guideCancelBtn');
const guideInputWrap = document.getElementById('guideInputWrap');
const guideInput = document.getElementById('guideInput');
const guideInputHint = document.getElementById('guideInputHint');
const guideSelectWrap = document.getElementById('guideSelectWrap');
const guideSelect = document.getElementById('guideSelect');
const guideSelectHint = document.getElementById('guideSelectHint');

function resetGuideExtras(){
  guideInputWrap.style.display='none';
  guideSelectWrap.style.display='none';
  guideCancelBtn.style.display='none';
  guideInput.value='';
  guideSelect.innerHTML='';
  guideInputHint.textContent='';
  guideSelectHint.textContent='';
}
function setGuideArrow(arrow){
  guideArrowEl.className = 'guideArrow ' + (arrow ? ('arrow-' + arrow) : 'arrow-none');
}
function showGuide(message, arrow='none', buttonText='OK'){
  resetGuideExtras();
  guideMessage.textContent = message || '';
  guideBtn.textContent = buttonText || 'OK';
  setGuideArrow(arrow);
  guideOverlay.style.display='flex';
  return new Promise(resolve=>{
    guideBtn.onclick = ()=>{ guideOverlay.style.display='none'; resolve(true); };
  });
}
function showGuideInput(message, arrow, placeholder='', buttonText='OK', hintText=''){
  resetGuideExtras();
  guideMessage.textContent = message || '';
  guideBtn.textContent = buttonText || 'OK';
  setGuideArrow(arrow);
  guideInputWrap.style.display = 'block';
  guideInput.placeholder = placeholder || '';
  guideInput.value = '';
  guideInputHint.textContent = hintText || '';
  guideCancelBtn.style.display = 'inline-block';
  guideOverlay.style.display = 'flex';
  setTimeout(()=>{ try{ guideInput.focus(); }catch(e){} },50);
  return new Promise(resolve=>{
    guideBtn.onclick = ()=>{
      const v=(guideInput.value||'').trim();
      guideOverlay.style.display='none';
      resolve(v||null);
    };
    guideCancelBtn.onclick = ()=>{
      guideOverlay.style.display='none';
      resolve(null);
    };
  });
}
function showGuideSelect(message, arrow, items, buttonText='決定', hintText=''){
  resetGuideExtras();
  guideMessage.textContent = message || '';
  guideBtn.textContent = buttonText || '決定';
  setGuideArrow(arrow);
  guideSelectWrap.style.display='block';
  guideSelectHint.textContent = hintText || '';
  guideSelect.innerHTML='';
  (items||[]).forEach((it, idx)=>{
    const opt=document.createElement('option');
    opt.value=String(it.value);
    opt.textContent=it.label;
    if(idx===0) opt.selected=true;
    guideSelect.appendChild(opt);
  });
  guideCancelBtn.style.display='inline-block';
  guideOverlay.style.display='flex';
  setTimeout(()=>{ try{ guideSelect.focus(); }catch(e){} },50);
  return new Promise(resolve=>{
    guideBtn.onclick=()=>{
      const v=guideSelect.value;
      guideOverlay.style.display='none';
      resolve(v ?? null);
    };
    guideCancelBtn.onclick=()=>{
      guideOverlay.style.display='none';
      resolve(null);
    };
  });
}

/* ---------- GAS/external detect ---------- */
function isGasHost(){
  return typeof google !== 'undefined' && google.script && google.script.run;
}

/* ---------- settings ---------- */
function loadSettings(){
  const u = localStorage.getItem(LS_URL)||'';
  const k = localStorage.getItem(LS_KEY)||'';
  const urlEl = document.getElementById('webappUrl');
  const keyEl = document.getElementById('apiKey');
  if(urlEl) urlEl.value = u;
  if(keyEl) keyEl.value = k;
}
function saveSettings(){
  localStorage.setItem(LS_URL, document.getElementById('webappUrl').value||'');
  localStorage.setItem(LS_KEY, document.getElementById('apiKey').value||'');
  alert('保存しました');
}
function getBase(){
  const urlEl = document.getElementById('webappUrl');
  const keyEl = document.getElementById('apiKey');
  const url=(urlEl ? (urlEl.value||'') : '').trim();
  const key=(keyEl ? (keyEl.value||'') : '').trim();
  if(!url || !key){
    try{
      const ext = document.getElementById('extSettings');
      if (ext) ext.style.display='block';
    }catch(e){}
    throw new Error('外部ホストでは「GAS WebアプリURL（.../exec）」と「APIキー」を入力して保存してください。');
  }
  return {url, key};
}

/* ---------- JSONP call ---------- */
function apiJsonpRaw(fn, argsArray){
  const base=getBase();
  const u=new URL(base.url);
  u.searchParams.set('api','1');
  u.searchParams.set('fn',fn);
  u.searchParams.set('key',base.key);

  // 引数→クエリ変換（GAS側 doGet の実装に合わせる）
  const map = {
    ping: [],
    getFaceDescriptors: [],
    getNameMasterOptions: [],
    getWeeklyStatus: ['name'],
    recordAttendance: ['name','kind'],
    recordPrivateOuting: ['name','kind','memo'],
    editAttendance: ['name','dateStr','field','mode','timeStr','freeText'],
    saveFaceDescriptors: ['name','descriptorsJson'],
    listPendingEditsForConfirmer: ['confirmer'],
    approveEdit: ['rowNo','confirmer']
  };
  const keys = map[fn];
  if(!keys) throw new Error('unknown api fn: '+fn);
  const a = Array.isArray(argsArray) ? argsArray : [];
  keys.forEach((k,i)=>{
    if(typeof a[i] !== 'undefined' && a[i] !== null){
      u.searchParams.set(k, String(a[i]));
    }
  });

  const cb='__cb_'+Math.random().toString(36).slice(2)+Date.now();
  u.searchParams.set('callback', cb);

  return new Promise((resolve,reject)=>{
    const timeoutMs=20000;
    const t=setTimeout(()=>{ cleanup(); reject(new Error('timeout')); }, timeoutMs);

    function cleanup(){
      clearTimeout(t);
      try{ delete window[cb]; }catch(e){ window[cb]=undefined; }
      if(script && script.parentNode) script.parentNode.removeChild(script);
    }

    window[cb]=(payload)=>{ cleanup(); resolve(payload); };

    const script=document.createElement('script');
    script.src=u.toString();
    script.async=true;
    script.onerror=()=>{ cleanup(); reject(new Error('script load error')); };
    document.head.appendChild(script);
  });
}

/* ---------- unified API ---------- */
function normalizeGasError(err){
  if(!err) return new Error('unknown error');
  if(err instanceof Error) return err;
  const msg = (err && err.message) ? err.message : String(err);
  return new Error(msg);
}
// fn は Code.gs の関数名（APIモードの fn と同名）
function callApi(fn, args){
  const a = Array.isArray(args) ? args : [];
  if (isGasHost()){
    return new Promise((resolve,reject)=>{
      try{
        google.script.run
          .withSuccessHandler(resolve)
          .withFailureHandler(e=>reject(normalizeGasError(e)))
          [fn](...a);
      }catch(e){
        reject(normalizeGasError(e));
      }
    });
  }
  // external: JSONP (CORS回避)
  return apiJsonpRaw(fn, a).then(payload=>{
    if(!payload || payload.ok !== true){
      throw new Error((payload && payload.error) ? payload.error : 'api error');
    }
    return payload.data;
  });
}

/* ---------- save face descriptors (POST + verify) ---------- */
async function saveFaceDescriptorsSafe(registerName, descriptorsObj){
  const payloadJson = JSON.stringify(descriptorsObj);

  // GAS host: normal call
  if (isGasHost()){
    return await callApi('saveFaceDescriptors', [registerName, payloadJson]);
  }

  const base = getBase(); // {url,key}

  // Before snapshot (to verify overwrite as well as new insert)
  let beforeStr = null;
  try{
    const beforeList = await callApi('getFaceDescriptors', []);
    if (Array.isArray(beforeList)){
      const b = beforeList.find(r => r && (r.name === registerName || r.label === registerName));
      if (b){
        const v = (typeof b.descriptor !== 'undefined') ? b.descriptor : b.descriptors;
        beforeStr = (typeof v === 'string') ? v : JSON.stringify(v);
      }
    }
  }catch(e){}

  const params = new URLSearchParams();
  params.set('api','1');
  params.set('fn','saveFaceDescriptorsPost');
  params.set('key', base.key);
  params.set('name', registerName);
  params.set('descriptorsJson', payloadJson);

  await fetch(base.url, {
    method: 'POST',
    mode: 'no-cors',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' },
    body: params.toString()
  });

  // Verify
  const deadline = Date.now() + 8000;
  let lastErr = null;
  while (Date.now() < deadline){
    await new Promise(r=>setTimeout(r, 500));
    try{
      const list = await callApi('getFaceDescriptors', []);
      if (!Array.isArray(list)) continue;
      const rec = list.find(r => r && (r.name === registerName || r.label === registerName));
      if (!rec) continue;

      const v = (typeof rec.descriptor !== 'undefined') ? rec.descriptor : rec.descriptors;
      if (typeof v === 'string'){
        const s = v.trim();
        if (s){
          if (beforeStr === null) return true;
          if (s !== beforeStr) return true;
        }
      }else{
        const s = JSON.stringify(v);
        if (s && s !== 'null' && s !== '[]'){
          if (beforeStr === null) return true;
          if (s !== beforeStr) return true;
        }
      }
    }catch(e){
      lastErr = e;
    }
  }
  const extra = lastErr ? (' / ' + lastErr.message) : '';
  throw new Error('保存確認に失敗しました（スプレッドシートが更新されていません）' + extra);
}

/* ---------- ping ---------- */
function apiPing(){
  if(isGasHost()){
    alert('GASホストで動作中のため疎通確認は不要です');
    return;
  }
  apiJsonpRaw('ping', [])
    .then(p=>alert(JSON.stringify(p)))
    .catch(e=>alert('ping NG: '+e.message));
}

/* ---------- face-api model load ---------- */
async function loadModelsInternal() {
  statusEl.textContent = '顔認証モデルを読み込み中...';
  log('顔認証モデルを読み込み中...');

  const CANDIDATE_URLS = [
    './weights/',
    'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights/'
  ];

  for (const url of CANDIDATE_URLS) {
    try {
      log(`モデル読み込み試行: ${url}`);
      await faceapi.nets.tinyFaceDetector.loadFromUri(url);
      await faceapi.nets.faceLandmark68Net.loadFromUri(url);
      await faceapi.nets.faceRecognitionNet.loadFromUri(url);
      modelsLoaded = true;
      statusEl.textContent = 'モデル読み込み中。';
      log(`モデル読み込み中: ${url}`);
      return;
    } catch (e) {
      console.error(e);
      log(`モデル読み込み失敗: ${url} / ${e.message}`);
    }
  }
  statusEl.textContent = 'モデルの読み込みに失敗しました。';
  throw new Error('すべてのCDNからモデルの読み込みに失敗しました');
}
async function ensureModelsLoaded() {
  if (modelsLoaded) return;
  if (!modelsLoadingPromise) {
    modelsLoadingPromise = loadModelsInternal().catch(err => {
      modelsLoaded = false;
      modelsLoadingPromise = null;
      throw err;
    });
  }
  await modelsLoadingPromise;
}

/* ---------- camera ---------- */
async function startCamera() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'user' },
      audio: false
    });
    video.srcObject = stream;
    try { await video.play(); } catch (e) {}
    statusEl.textContent = 'カメラ起動完了。';
    log('カメラ起動完了。');
  } catch (e) {
    console.error(e);
    statusEl.textContent = 'カメラを起動できません: ' + e.message;
    log('カメラ起動エラー: ' + e.message);
  }
}

/* ---------- select face in guide ---------- */
function selectFaceInGuide(detections) {
  if (!detections || detections.length === 0) return null;

  const guide = {
    x: video.videoWidth * 0.19,
    y: video.videoHeight * 0.16,
    w: video.videoWidth * 0.62,
    h: video.videoHeight * 0.68
  };

  let best = null;
  let bestOverlap = 0;

  detections.forEach(d => {
    const b = d.detection.box;
    const xOverlap = Math.max(0, Math.min(b.x + b.width, guide.x + guide.w) - Math.max(b.x, guide.x));
    const yOverlap = Math.max(0, Math.min(b.y + b.height, guide.y + guide.h) - Math.max(b.y, guide.y));
    const area = xOverlap * yOverlap;
    if (area > bestOverlap) {
      bestOverlap = area;
      best = d;
    }
  });

  return best;
}

/* ---------- capture descriptor ---------- */
async function captureDescriptor() {
  await ensureModelsLoaded();
  try { await video.play(); } catch (e) {}
  await new Promise(r => setTimeout(r, 120));

  const options = new faceapi.TinyFaceDetectorOptions({
    inputSize: 320,
    scoreThreshold: 0.5
  });

  const detections = await faceapi
    .detectAllFaces(video, options)
    .withFaceLandmarks()
    .withFaceDescriptors();

  if (!detections || detections.length === 0) return null;

  const selected = selectFaceInGuide(detections);
  if (!selected) return null;

  return selected.descriptor;
}

/* ---------- load descriptors ---------- */
async function loadDescriptors(){
  await ensureModelsLoaded();
  try{
    let data;
    data = await callApi('getFaceDescriptors', []);

    if (!data || !Array.isArray(data) || data.length === 0) {
      labeledDescriptors = [];
      statusEl.textContent = 'まだ顔データが登録されていません。';
      log('顔データ0件');
      return;
    }

    const map = new Map();
    data.forEach(item=>{
      const name = item.name || item.label || '';
      let arr = item.descriptor || item.descriptors;
      if(!name || !arr) return;

      if (typeof arr === 'string') {
        try { arr = JSON.parse(arr); } catch(e) {}
      }
      if (arr && !Array.isArray(arr) && typeof arr === 'object') {
        try { arr = Object.values(arr); } catch(e) {}
      }
      if (Array.isArray(arr) && typeof arr[0] === 'number') {
        const d = new Float32Array(arr);
        if(!map.has(name)) map.set(name, []);
        map.get(name).push(d);
        return;
      }
      if (Array.isArray(arr) && Array.isArray(arr[0])) {
        arr.forEach(a=>{
          if (!Array.isArray(a)) return;
          const d = new Float32Array(a);
          if(!map.has(name)) map.set(name, []);
          map.get(name).push(d);
        });
      }
    });

    labeledDescriptors = Array.from(map.entries()).map(([name, descList]) => new faceapi.LabeledFaceDescriptors(name, descList));
    log(`顔データ読み込み: ${labeledDescriptors.length}名`);
    statusEl.textContent = '顔データ読み込み完了。';
  }catch(err){
    console.error(err);
    statusEl.textContent = '顔データ読み込み失敗: ' + err.message;
    log('顔データ読み込み失敗: ' + err.message);
  }
}

/* ---------- recognized user ---------- */
function setRecognizedUser(name, message){
  recognizedName = name || '';
  userNameEl.textContent = recognizedName ? recognizedName : '未認識';
  if (message) statusEl.textContent = message;
  // 顔認証後の週次表示
  loadWeeklyStatus();
  // ★ 承認パネルは「未承認がある時だけ」出す
  updateApprovePanelAfterRecognize();
}
function clearRecognizedUser(message){
  recognizedName = '';
  userNameEl.textContent = '未認識';
  if (message) statusEl.textContent = message;
  hideApprovePanelHard();
}

/* ---------- weekly status ---------- */
async function loadWeeklyStatus(){
  if(!recognizedName){
    document.getElementById('weeklyStatus').textContent = '顔認証後に読み込みます...';
    return;
  }
  try{
    const data = await callApi('getWeeklyStatus', [recognizedName]);
    if(!data || !data.days){
      document.getElementById('weeklyStatus').textContent = '週次データがありません';
      return;
    }
    const days = data.days;
    let html = '<table class="weekly-table"><thead><tr><th>日付</th><th>出勤</th><th>退勤</th></tr></thead><tbody>';
    days.forEach(d=>{
      const cls = d.isHoliday ? 'weekly-holiday' : ((d.start && d.end) ? 'weekly-ok' : 'weekly-missing');
      html += `<tr class="${cls}"><td>${d.date}</td><td>${d.start||''}</td><td>${d.end||''}</td></tr>`;
    });
    html += '</tbody></table>';
    document.getElementById('weeklyStatus').innerHTML = html;
  }catch(e){
    document.getElementById('weeklyStatus').textContent = '週次表示エラー: ' + e.message;
  }
}

/* ---------- face register ---------- */
async function onRegisterFace(){
  if(registerInProgress) return;
  registerInProgress = true;

  try{
    if(!labeledDescriptors) labeledDescriptors = [];

    const nameOptions = await (async()=>{
      try{
        const opts = await callApi('getNameMasterOptions', []);
        if(Array.isArray(opts) && opts.length) return opts;
      }catch(e){}
      return [];
    })();

    let registerName = null;
    if(nameOptions.length){
      const items = nameOptions.map(n=>({value:n, label:n}));
      registerName = await showGuideSelect('氏名を選択してください（氏名マスタ）', 'none', items, 'この名前で登録', '※氏名マスタに無い場合はGAS側のシートを確認してください');
      if(!registerName) return;
    }else{
      registerName = await showGuideInput('登録する氏名を入力してください', 'none', '例：山田太郎', '次へ', '※氏名マスタが取得できない場合は手入力になります');
      if(!registerName) return;
    }

    const steps = [
      {msg:'正面を向いてください', arrow:'none'},
      {msg:'右を向いてください', arrow:'right'},
      {msg:'左を向いてください', arrow:'left'},
    ];

    const registerDescriptors = [];

    for (let i = 0; i < steps.length; i++) {
      await showGuide(steps[i].msg, steps[i].arrow, '撮影する');

      statusEl.textContent = `顔登録中...（${i + 1}/3）`;
      log(`顔登録 ${i + 1}/3`);

      const desc = await captureDescriptor();

      if (!desc) {
        await showGuide(
          '顔を検出できませんでした。\n\n・顔が枠内に入っているか\n・明るさ\n・他の人の顔が近くに大きく映っていないか\n\n確認してもう一度撮影してください。',
          'up',
          'もう一度撮影'
        );
        i--;
        continue;
      }

      registerDescriptors.push(Array.from(desc));

      if (i < steps.length - 1) {
        await showGuide('OKです。次の向きに進みます。', 'none', '次へ');
      }
    }

    await showGuide('3回の撮影が完了しました。\n保存します。', 'none', '保存する');
    statusEl.textContent = '保存中...';

    try{
      await saveFaceDescriptorsSafe(registerName, registerDescriptors);
      statusEl.textContent = `顔登録完了: ${registerName}`;
      log(`顔登録完了: ${registerName}（3回）`);
      await showGuide('顔登録が完了しました。', 'none', '閉じる');
      await loadDescriptors();
    }catch(err){
      console.error(err);
      statusEl.textContent = '顔登録に失敗しました: ' + err.message;
      alert('顔登録エラー: ' + err.message);
    }

  } catch (e) {
    console.error(e);
    alert('顔登録処理でエラー: ' + e.message);
  } finally {
    registerInProgress = false;
  }
}

/* ---------- face recognize ---------- */
async function onRecognizeFace() {
  if (!labeledDescriptors || labeledDescriptors.length === 0) {
    alert('まだ顔データがありません。先に「顔登録」を行ってください。');
    return;
  }

  statusEl.textContent = '顔認証中...';
  log('顔認証開始');

  let desc;
  try {
    desc = await captureDescriptor();
  } catch (e) {
    alert('モデル読み込み等で失敗しました: ' + e.message);
    return;
  }

  if (!desc) {
    statusEl.textContent = '顔を検出できませんでした。';
    alert('顔が検出できませんでした。枠の中に顔を入れてください。');
    return;
  }

  const threshold = 0.5;
  const margin = 0.03;

  const distances = [];
  labeledDescriptors.forEach(ld=>{
    const d = faceapi.euclideanDistance(desc, ld.descriptors[0]);
    distances.push({name: ld.label, distance: d});
  });

  distances.sort((a,b)=>a.distance-b.distance);

  const best = distances[0];
  if (!best || best.distance > threshold) {
    clearRecognizedUser('一致する顔が見つかりませんでした。');
    log(`未認識: dist=${best ? best.distance.toFixed(3) : 'N/A'}`);
    alert('登録済みの顔データと一致しませんでした。');
    return;
  }

  const candidates = distances.filter(d => d.distance <= best.distance + margin && d.distance <= threshold);

  if (candidates.length === 1) {
    setRecognizedUser(best.name, `顔認証成功: ${best.name}`);
    return;
  }

  const items = candidates.map((c, i) => ({
    value: String(i),
    label: `${c.name}（距離: ${c.distance.toFixed(3)}）`
  }));

  const picked = await showGuideSelect(
    '複数の候補が見つかりました。選択してください。',
    'none',
    items,
    'この人にする',
    '※「キャンセル」で認証は確定しません。'
  );

  if (picked === null) {
    clearRecognizedUser('顔認証をキャンセルしました。');
    return;
  }

  const idx = parseInt(picked, 10);
  if (isNaN(idx) || idx < 0 || idx >= candidates.length) {
    clearRecognizedUser('不正な選択です。');
    alert('選択が正しくありません。');
    return;
  }

  setRecognizedUser(candidates[idx].name, `顔認証成功（選択）: ${candidates[idx].name}`);
}

/* ---------- attendance ---------- */
function onClickStart() {
  if (!recognizedName) { alert('先に「顔認証」を行ってください。'); return; }
  const kind = 'start';

  statusEl.textContent = '出勤を記録中...';
  log(`出勤打刻: ${recognizedName}, kind=${kind}`);

  callApi('recordAttendance', [recognizedName, kind])
    .then(function (result) {
      statusEl.textContent = '出勤を記録しました。';
      log(`出勤OK`);
      alert(`出勤を記録しました。\n${recognizedName}\n値: ${result.value}`);
      loadWeeklyStatus();
    })
    .catch(function (err) {
      console.error(err);
      statusEl.textContent = '出勤の記録に失敗しました: ' + err.message;
      log('出勤エラー: ' + err.message);
      alert('出勤の記録に失敗しました: ' + err.message);
    });
}
function onClickEnd() {
  if (!recognizedName) { alert('先に「顔認証」を行ってください。'); return; }
  const kind = 'end';

  statusEl.textContent = '退勤を記録中...';
  log(`退勤打刻: ${recognizedName}, kind=${kind}`);

  callApi('recordAttendance', [recognizedName, kind])
    .then(function (result) {
      statusEl.textContent = '退勤を記録しました。';
      log(`退勤OK`);
      alert(`退勤を記録しました。\n${recognizedName}\n値: ${result.value}`);
      loadWeeklyStatus();
    })
    .catch(function (err) {
      console.error(err);
      statusEl.textContent = '退勤の記録に失敗しました: ' + err.message;
      log('退勤エラー: ' + err.message);
      alert('退勤の記録に失敗しました: ' + err.message);
    });
}

/* ---------- private outing ---------- */
function onPrivateOut() {
  if (!recognizedName) { alert('先に「顔認証」を行ってください。'); return; }
  const memo = (document.getElementById('privateMemo').value || '').trim();
  statusEl.textContent = '外出開始を記録中...';
  callApi('recordPrivateOuting', [recognizedName, 'out', memo])
    .then(function (res) {
      statusEl.textContent = '外出開始を記録しました。';
      alert(`外出開始を記録しました\n${recognizedName}\n${res.date} ${res.time}`);
    })
    .catch(function (err) {
      alert('外出開始の記録に失敗しました: ' + err.message);
    });
}
function onPrivateBack() {
  if (!recognizedName) { alert('先に「顔認証」を行ってください。'); return; }
  const memo = (document.getElementById('privateMemo').value || '').trim();
  statusEl.textContent = '戻りを記録中...';
  callApi('recordPrivateOuting', [recognizedName, 'back', memo])
    .then(function (res) {
      statusEl.textContent = '戻りを記録しました。';
      const extra = (res && res.message) ? (`\n\n${res.message}`) : '';
      alert(`戻りを記録しました\n${recognizedName}\n${res.date} ${res.time}${extra}`);
    })
    .catch(function (err) {
      alert('戻りの記録に失敗しました: ' + err.message);
    });
}

/* ---------- edit ---------- */
function convertDateInputToSheetDate(dateInput) {
  if (!dateInput) return '';
  const parts = dateInput.split('-');
  if (parts.length !== 3) return dateInput;
  return parts[0] + '/' + parts[1] + '/' + parts[2];
}
function onEdit(){
  if (!recognizedName) { alert('先に「顔認証」を行ってください。'); return; }
  const dateStr = convertDateInputToSheetDate(document.getElementById('editDate').value||'');
  const field = document.getElementById('editField').value;
  const mode = document.getElementById('editMode').value;
  const timeStr = (document.getElementById('editTime').value||'').trim();
  const freeText = (document.getElementById('editFreeText').value||'').trim();

  if(!dateStr){ alert('対象日を選択してください'); return; }
  if(mode==='set' && !timeStr){ alert('時刻を入力してください'); return; }

  statusEl.textContent = '修正を保存中...';
  callApi('editAttendance', [recognizedName, dateStr, field, mode, timeStr, freeText])
    .then(res=>{
      statusEl.textContent = '修正を保存しました（承認待ちの場合があります）';
      alert('修正を保存しました');
      loadWeeklyStatus();
      // 修正後、確認者なら承認一覧が変わるので更新
      updateApprovePanelAfterRecognize();
    })
    .catch(err=>{
      statusEl.textContent = '修正に失敗しました: ' + err.message;
      alert('修正エラー: ' + err.message);
    });
}

/* ============================================================
   ★承認パネル：未承認がある確認者だけ表示
   ============================================================ */
function esc(s){ return String(s??'').replace(/[&<>"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c])); }

function hideApprovePanelHard(){
  const p=document.getElementById('approvePanel');
  if(p) p.style.display='none';
  const hint=document.getElementById('approveHint');
  if(hint) hint.textContent='';
}

function showApprovePanelWithHint(count){
  const p=document.getElementById('approvePanel');
  if(!p) return;
  p.style.display='block';
  const hint=document.getElementById('approveHint');
  if(hint){
    const n = recognizedName || '';
    hint.textContent = n ? (`確認者：${n}（未承認 ${count} 件）`) : '';
  }
}

function renderApproveRows(rows){
  const tbody=document.getElementById('approveTbody');
  if(!tbody) return;
  tbody.innerHTML='';
  if(!rows || !rows.length){
    tbody.innerHTML='<tr><td colspan="6" class="small" style="padding:10px 6px;color:#666">未承認の修正はありません。</td></tr>';
    return;
  }
  rows.forEach(r=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td style="border-bottom:1px solid #eee;padding:8px 6px;">
        <button class="btn btn-primary" data-row="${esc(r.rowNo)}">承認</button>
      </td>
      <td style="border-bottom:1px solid #eee;padding:8px 6px;">${esc(r.target||r.name||'')}</td>
      <td style="border-bottom:1px solid #eee;padding:8px 6px;">${esc(r.date||r.dateStr||'')}</td>
      <td style="border-bottom:1px solid #eee;padding:8px 6px;">${esc(r.mode||r.field||'')}</td>
      <td style="border-bottom:1px solid #eee;padding:8px 6px;">${esc(r.oldValue||r.before||'')} → ${esc(r.newValue||r.after||'')}</td>
      <td style="border-bottom:1px solid #eee;padding:8px 6px;font-size:12px;color:#555">
        ${esc((r.actor||r.requester||'') + ' / ' + (r.sheet||'') + ' / ' + (r.editedAt||r.createdAt||''))}
      </td>
    `;
    tbody.appendChild(tr);
    tr.querySelector('button').addEventListener('click', ()=>{
      const rowNo = Number(r.rowNo||0);
      if(!rowNo) return alert('rowNoが不正です');
      if(!recognizedName) return alert('先に顔認証してください');
      if(!confirm(`承認しますか？\n確認者: ${recognizedName}\nrowNo: ${rowNo}`)) return;

      callApi('approveEdit', [rowNo, recognizedName])
        .then(()=>{
          alert('承認しました');
          // 再取得（0件になったらパネルを消す）
          loadPendingEdits(false);
        })
        .catch(err=>alert('承認に失敗: ' + err.message));
    });
  });
}

/**
 * loadPendingEdits(forceShow)
 * - forceShow=true: ボタン押下など（取得はするが、0件なら結局非表示）
 * - forceShow=false: 自動判定（顔認証後など）
 */
async function loadPendingEdits(forceShow){
  if(!recognizedName){
    hideApprovePanelHard();
    return;
  }

  // 取得中表示（ただしパネルは出しっぱなしにしない方針なので、ここでは表示しない）
  try{
    const rows = await callApi('listPendingEditsForConfirmer', [recognizedName]);
    const list = Array.isArray(rows) ? rows : [];
    const count = list.length;

    if(count <= 0){
      // ★最優先要件：対象がないならパネルは出さない
      hideApprovePanelHard();
      if(forceShow){
        alert('未承認の修正はありません（パネルは表示しません）');
      }
      return;
    }

    // 対象がある → 表示して描画
    showApprovePanelWithHint(count);
    renderApproveRows(list);
  }catch(err){
    // エラー時も “パネル常時表示” はしない（誤表示防止）
    hideApprovePanelHard();
    if(forceShow){
      alert('未承認一覧の取得に失敗: ' + err.message);
    }
  }
}

/* 顔認証直後に「確認者対象があるか」だけ判定して、あれば表示 */
function updateApprovePanelAfterRecognize(){
  // 既存UIをいじらないため、DOM作り直し等はしない
  loadPendingEdits(false);
}

/* ---------- init ---------- */
(async function init(){
  loadSettings();

  // 外部ホストなら設定パネルを出す（ただし入力がある場合は非表示のままでもOK）
  if(!isGasHost()){
    // ここでは消しません（UI崩れ回避）。getBase() で必要時に開く
  }else{
    // GAS内なら extSettings は出さない
    try{ document.getElementById('extSettings').style.display='none'; }catch(e){}
  }

  await startCamera();
  try{
    await loadDescriptors();
  }catch(e){}

  statusEl.textContent = '準備完了。';
})();
</script>

</body>
</html>
